<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Doppler effect</title>
    <link rel="icon" href="static\assets\icons\webapp icon.png" type="image/png">
    <style>
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh; /* Set a minimum height */
            width: 100vw;
            margin: 0;
            padding: 0;
            position: fixed;
            /* overflow: hidden; */
            background-color: whitesmoke;
            color: #f9f9f9;
        }

        .canvas-container {
            position: relative;
        }

        .canvas-container div {
            position: relative;
            background-repeat: no-repeat;
        }

        #canvas-container {
            position: absolute;
            background-repeat: no-repeat;
            width: 100%;
            height: 100%;
            z-index: 0;
            top: 0px;
        }

        #pixelCanvas {
            position: absolute;
            left: calc(50vw - (100vh) / 2);
            top: calc(50vh - (100vh) / 2);;
            width: 100vh;
            height: 100vh;
        }



        #vectors {
            position: absolute;
            top: 0px;
            left: 1px;
            width: 15%;
            min-width: 300px;
            z-index: 4;
            height: 100%;
            width: calc(max(15vw, 100px));
        }

        #vector-buttons {
            position: relative;
            text-align: center;
            top: max(5px, 1%);;
            left: 0%;
            z-index: 5;
        }

        .SliderDiv {
            position: relative;
        }

        #vectorsContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            top: max(30px, 5%);
            z-index: 2;
        }

        .vector-field {
            margin-top: 10px;
            margin-left: 2%;
            display: inline-block;
            width: 92%;
            height: fit-content;
            padding: 5px;
            border-style: inset;
            padding-top: 20px;
            padding-bottom: 75vh;
            border-color: rgb(219, 219, 219);
        }

        .Slider{
            width: max(90%, 40px);
        }

        .vector-field input:not(.Slider) {
            width: max(20%, 40px); /* Set the desired width */
            margin-right: 3%;
        }

        .InputMatrix {
            margin-top: 10px;
        }



        #cosmetic-divs {
            position: absolute;
            height: 100%;
            width: 100%;
            z-index: 3;
        }

        .cosmetic-div {
            position: absolute;
            background-color: rgb(90, 90, 90);
            min-width: 300px;
        }

        #vector-big-border {
            position: absolute;
            top: -1%;
            left: 0%;
            width: calc(max(15vw, 100px));
            height: 306%;
            z-index: 3;
            border: solid rgb(184, 177, 177);
        }

        #vector-small-border {
            position: absolute;
            top: max(40px, 5%);
            left: 0%;
            width: calc(max(15vw, 100px));
            height: 300%;
            z-index: 3;
            border: solid rgb(184, 177, 177);
        }



        #canvas-div {
            top: 0%;
            position: absolute;
            right: 0;
            width: calc(100vw - max(15vw, 100px));
            height: inherit;
            align-items: center;
            justify-content: center;
        }        

        #Resultvectors {
            top: 20%;
            left: 120%;
            width: 300px;
        }

        .result-label {
            width: 50px; /* Set the desired width */
            margin-right: 15px;
        }

        #ErrorField {
            top: 48%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: rgb(255, 0, 0);
            font-size: larger;
            font-family: 'Segoe UI';
            font-weight: bold;
        }

        #ErrorField label{
            text-align: center;
            color: rgb(255, 0, 0);
            font-size: larger;
            font: bolder;
        }

        #Slider {
            text-align: center;
        }



        #render-button-holder {
            top: 0;
            left: 0;
            transform: translate(-100%, -92%);
            width: 35px; /* 5% of the canvas width */
            height: 35px; /* 5% of the canvas height */
            z-index: 3;
        }

        #render-button {
            border: none;
            background: none;
        }

        #render-button img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: brightness(1.25);
        }

       
        
        .input-group {
            margin-top: 10px;
            margin-bottom: 10px;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pixel {
            width: 10px;
            height: 10px;
            display: inline-block;
            margin: 1px;
        }

        #vectorsContainer {
            margin-top: 10px;
        }

        .InputMatrix {
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .Resultvectors {
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .selectorDiv {
            align-items: start;
            margin-top: 20px;
        }

        #ModelSelector {
            margin-left: 20px;
            left: 0px;
        }

        .handout {
            color: rgb(149, 198, 255);
            text-decoration: none;
            margin: 3rem;
            margin-left: 1rem;
        }

    </style>
</head>
<body id="body">
    <div id="container"></div>

        <br>

        <!-- <div id="input-group">
        <label for="inputData">Enter Data:</label>
        <input type="text" id="inputData" placeholder="Type something...">
        <button onclick="sendPutRequest()">Send PUT Request</button>
        </div> -->

        <div id="result"> </div>

        <br> <br> <br>

        <div class="canvas-container" id="canvas-container">
            <div id="cosmetic-divs">
                <div id="vector-big-border" class="cosmetic-div"></div>
                <div id="vector-small-border" class="cosmetic-div"></div>
            </div>
            <div id="vectors">
                <div id="vector-buttons">
                    <button onclick="togglePlay()">Play</button>
                </div>

                <div id="vectorsContainer">
                    <!-- Vector fields will be added here dynamically -->
                    <a class="handout" href="https://drive.google.com/file/d/1H_YxxZf_e2oossALDehiBT9-DZH8esPG/view?usp=sharing" target="_other">Handout</a>
                </div>
            </div>
            <!-- <div class="upper-left-corner">
                <img src="/static/assets/canvas-border/upper_left_corner.png" alt="canvas border">
            </div> -->
            <div id="render-button-holder">
                <button id="render-button" onclick="renderButtonPush()">
                    <img src='static/assets/buttons/green_dot.png' alt="render button">
                </button>
            </div>
            <!-- <div id='Resultvectors'>
                <label for="Computed Vectors:">Computed Vectors:</label>
            </div> -->
            <div id='ErrorField'>
                <label id="Error-Message"></label>
            </div>
            <div id="canvas-div">
                <canvas id="pixelCanvas"></canvas>
            </div>
        </div>

        <br>
        <br>

        

        <br>

        <!-- <div id="InputMatrix">
            <label for="inputMatrix">Rotation Matrix:</label>
            <br>
            <input type="text" id="lineX1" placeholder="Line X, Element 1">
            <input type="text" id="lineX2" placeholder="Line X, Element 2">
            <input type="text" id="lineX3" placeholder="Line X, Element 3">
            <br>
            <input type="text" id="lineY1" placeholder="Line Y, Element 1">
            <input type="text" id="lineY2" placeholder="Line Y, Element 2">
            <input type="text" id="lineY3" placeholder="Line Y, Element 3">
            <br>
            <input type="text" id="lineZ1" placeholder="Line Z, Element 1">
            <input type="text" id="lineZ2" placeholder="Line Z, Element 2">
            <input type="text" id="lineZ3" placeholder="Line Z, Element 3">
            <br>
            <br>
        </div>

        <br>

        <div id="Slider">
            <label id="angle-slider-label">Selected Angle: 0Â°</label>
            <br>
            <input id="angle-slider" type="range" min="1" max="360" step="0" value="0" oninput="updateSliderText('angle-slider', 'angle-slider-label', 'Selected Angle:'), sendPutRequest()">
        </div> -->

        

        <br>
        <br>

    </div>
   

    <script>

        const colorOptions = ["green", "red", "blue", "purple"]
        var renderLists = [];
        var pendingRequest = false;
        var play = false;
        var speed = 0.01;

        function togglePlay() {
            play = !play;
        }

        function forgetRequest() {
            pendingRequest = false;
        }

        function getDisplayResolution() {
            const resolution = [];

            resolution.push(window.innerWidth); 
            resolution.push(window.innerHeight);
        
            return resolution;
        }

        function determineCanvasResolution() {
            const displayResolution = getDisplayResolution();
            let resolution = Math.min(Math.round(displayResolution[0]) - Math.round(displayResolution[0]) % 128.0, 1028)
            return [resolution, resolution];
        }

        function setCanvasSize(canvasId, resolution) {
            const canvas = document.getElementById(canvasId);
            canvas.width = `${resolution[0]}`
            canvas.height = `${resolution[1]}`
        }

        function createSlider(number) {
            var sliderDiv = document.createElement("div");
            sliderDiv.id = `SliderDiv_${number}`;
            sliderDiv.className = "SliderDiv";

            var label = document.createElement("label");
            label.id = `SliderLabel_${number}`;
            label.textContent = "Timescale: 0.0";

            var slider = document.createElement("input");
            slider.className = "Slider"
            slider.type = "range";
            slider.id = `Slider_${number}`;
            slider.min = "0.0";
            slider.max = "1.0";
            slider.step = "0.01";
            slider.width = "120px";
            slider.value = 0;
            slider.oninput = function() {
                updateSliderText(`Slider_${number}`, `SliderLabel_${number}`, 'Timescale:');
                // manipulateMatrixInputTextBrackets(document.getElementById(`Slider_${number}`).value || "0", `${number}`)
                sendPutRequest(number);
            };

            sliderDiv.appendChild(label);
            sliderDiv.appendChild(document.createElement("br"));
            sliderDiv.appendChild(slider);

            return sliderDiv;
        }

        function IncrementSlider() {
            const id =`Slider_${-1}`; 
            const laber_id = `SliderLabel_${-1}`;
            const change = speed;
            console.log("increasing slider value")
            var sliderDiv = document.getElementById(`${id}`);
            const newValue = parseFloat(sliderDiv.value) + change;

            if (newValue < 0.95 && newValue > 0.0 && play) {
                sliderDiv.value = newValue;
                updateSliderText(id, laber_id, 'Timescale:')
                sendPutRequest()
            }
        }

        function updateSliderText(sliderId, LabelId, LabelText) {
            const slider = document.getElementById(sliderId);
            const sliderLabel = document.getElementById(LabelId);
            
            sliderLabel.innerText = `${LabelText} ${slider.value}`
        }

        function translateColor(colorText) {
            const dummyDiv = document.createElement("div");
            dummyDiv.style.color = colorText;
            document.body.appendChild(dummyDiv);

            const transformedColorText = window.getComputedStyle(dummyDiv).color;

            document.body.removeChild(dummyDiv);

            const matchedColor = transformedColorText.match(/\d+/g);
            if (matchedColor) {
                const result = {
                    red: Math.min(parseInt(matchedColor[0]) * 10, 255),
                    green: Math.min(parseInt(matchedColor[1]) * 10, 255),
                    blue: Math.min(parseInt(matchedColor[2]) * 10, 255),
                }
                console.log(`AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ${result.green}`);
                return result;
            } else {
                const result = {
                    red: 0,
                    green: 255,
                    blue: 0
                }
                return result;
            }
        }

        let vectorCounter = -1; // Counter to keep track of the number of vectors


        // TODO: REWORK FOR JUST ROTATION MATRIX
        function addVector(name) {
            if (vectorCounter < 2) {
                const vectorsContainer = document.getElementById("vectorsContainer");
                vectorsContainer.style.border = "bold"

                // Create HTML elements for X, Y, Z fields
                const vectorDiv = document.createElement("div");
                vectorDiv.classList.add("vector-field");
                vectorDiv.id = `vector${vectorCounter}`;
                //vectorDiv.className = "vector";

                const Name = document.createElement("label");
                Name.textContent = `${name}:`;

                const lineBreak = document.createElement("br");

                slider = createSlider(vectorCounter);
                slider.top = "70px"

                const options = ["standard", "straight", "sound-barrier", "observer"];
                selector = addSelector(options, "ModelSelector");

                // Append elements to the container
                vectorsContainer.appendChild(vectorDiv);
                vectorDiv.appendChild(Name);
                vectorDiv.appendChild(lineBreak);
                // vectorDiv.appendChild(labelX);
                // vectorDiv.appendChild(inputX);
                // vectorDiv.appendChild(labelY);
                // vectorDiv.appendChild(inputY);
                // vectorDiv.appendChild(labelZ);
                // vectorDiv.appendChild(inputZ);
                // vectorDiv.appendChild(createRotationMatrix(vectorCounter));
                vectorDiv.appendChild(slider);
                vectorDiv.appendChild(selector);

                vectorCounter++;
                const topPosition = vectorCounter * 30; // Adjust this value based on your layout
                vectorDiv.style.top = `${topPosition}px`;

                var colorIndex = vectorCounter % colorOptions.length;
                if (colorIndex < 0) {
                    colorIndex = colorOptions.length + colorIndex - 1;
                }

                sendPutRequest(vectorCounter - 1);
            }
        }

        function removeVector() {
            if (vectorCounter > -1) {
                const vectorsContainer = document.getElementById("vectorsContainer");
                const lastVectorDiv = document.getElementById(`vector${vectorCounter - 1}`);

                vectorsContainer.removeChild(lastVectorDiv);
                vectorCounter--;
                renderLists = filterListEntry(renderLists, vectorCounter);
                drawPixelCube(renderLists, "white");
            }
        }

        class RenderedVector {
            constructor(layer, render, number) {
                this.layer = layer;
                this.render = render;
                this.number = number;
            }
        }



        function addSelector(options, selectorId) {
            const selectorDiv = document.createElement("div");
            selectorDiv.className = "selectorDiv";

            const label = document.createElement("label");
            label.textContent = "Select Option:";

            const selector = document.createElement("select");
            selector.id = selectorId;

            options.forEach(option => {
                const optionElement = document.createElement("option");
                optionElement.value = option;
                optionElement.textContent = option;
                selector.appendChild(optionElement);
            });

            selectorDiv.appendChild(label);
            selectorDiv.appendChild(selector);

            return selectorDiv;
        }

        function getSelectedValue(selectorId) {
            const selector = document.getElementById(selectorId);
            return selector.value;
        }

        

        async function sendPutRequest(number) {

            if (!pendingRequest) {

                // pendingRequest = true;
                
            
            const url = 'https://dopplerphysics.mywire.org/api/pull-request';
            const title = "Client calculation Request";
            const description = "Package containing data ment to be calcualted and renderd by the server";

            const resolution = determineCanvasResolution();

            // Get all Vectors and Rotation Matrixes
            const matrixes = [];
            const angels = [];

            const lineX = ['1.0', '0.0', '0.0'];
            const lineY = ['0.0', '1.0', '0.0'];
            const lineZ = ['0.0', '0.0', '1.0'];

            var matrixArray = [lineX, lineY, lineZ];

            var theta = parseFloat("0");

            var Color = {
                red: 0,
                green: 0,
                blue: 0
            }

            const cameraPosition = {x: 0.0, y: 0.0, z: -5.0}

            const focusPoint = {x: 0.0,y: 0.0, z: 0.0}

            // if (number == "X" || number == "x") {
            //     vectorX = parseFloat('10.0');
            // } 

            // else if (number == "Y" || number == "y") {
            //     vectorY = parseFloat('10.0');
            // } 

            // else if (number == "Z" || number == "z") {
            //     vectorZ = parseFloat('10.0');
            // } 

            // else {
            //     vectorX = parseFloat(document.getElementById(`vector${number}X`).value || '1.0');
            //     vectorY = parseFloat(document.getElementById(`vector${number}Y`).value || '1.0');
            //     vectorZ = parseFloat(document.getElementById(`vector${number}Z`).value || '1.0');

            //     matrixArray = readRotationMatrix(number);
                
            theta = parseFloat("0") / 180 * 3.141;
            angels.push(theta);

            theta = parseFloat("0") / 180 * 3.141;
            angels.push(theta);

            theta = parseFloat("0") / 180 * 3.141;
            angels.push(theta);

            //     var colorIndex = (number + 1) % colorOptions.length;
            //     if (colorIndex < 0) {
            //         colorIndex = colorOptions.length + colorIndex;
            //     }

            //     Color = translateColor(colorOptions[colorIndex]);
            // }

            const matrix = {
                line_x: matrixArray[0],
                line_y: matrixArray[1],
                line_z: matrixArray[2]
            }
            matrixes.push(matrix);

            angels.push(theta);


            let timescale = parseFloat(document.getElementById(`Slider_${-1}`).value || "0.0")

            let model = getSelectedValue("ModelSelector");
                
            
            const data = {
                title,
                description,
                resolution,
                matrix: matrixes,
                theta: angels,
                camera_position: cameraPosition,
                focus_point: focusPoint,
                fov: 80.0,
                timescale,
                model
            };
            try {
                console.log(`sending data: ${JSON.stringify(data)}`)
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data),
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.error != "No Error detected") {
                        console.error(`Error occured during server calculations: ${result.error}`);
                        console.log('Drawing empty canvas');
                        console.log(result);
                        drawPixelCube([]);
                        document.getElementById('ErrorField').innerText = `An Error Occured:\n"${result.error}"\nTrying some different inputs might fix it\nIf you dont understand the meaning of this message you are welcom to ask me\nunless you dont't know english. In which case all you can do is look at the screen in cofusion I guess`;
                        renderButtonRelease();
                    } else {
                                      
                        renderLists = result.color_list;
                        // const sortedList = renderLists;
                        // renderLists = sortedList;
                        // if (renderLists.length > 1) {
                        //     renderLists.reverse();
                        // }
                        console.log('Color Lists:', renderLists);
                        
                        document.getElementById('ErrorField').innerText = "";
                        console.log('PUT request successful with result: ');
                        console.log(result);
                        console.log('Color List:', result.color_list);
                        // document.getElementById('result').innerText = result.title;
                        drawPixelCube(renderLists, "white", result.resolution);
                        // document.getElementById('Resultvectors').innerText = "Computed Vectors: \n\n"
                        // writeResultVectors(vectorCounter, result.vectors)
                    }
                    
                } else {
                    console.error('PUT request failed:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('Error during PUT request:', error);
            }
        
            pendingRequest = false;
        }
        }


        async function drawPixelCube(renderLists, backgroundColor, resolution) {

            console.log('trying to draw');

            const PixelCube = document.getElementById("pixelCanvas");
            const CanvasContext = PixelCube.getContext("2d");
            const pixelSize = 1;

            // if (renderLists.length != pixelCanvas.height / pixelSize) {
            //     console.error("Data ment for canvas does not fit it's confines");
            // }

            console.log("Data used to draw on canvas: \nCanvas width: " + pixelCanvas.width + "\nCanvas height: " + pixelCanvas.height + "\npixel list: " + renderLists);

            CanvasContext.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);

            var rowLength = 0;
            var rowNumber = 1;

            const xResolution = resolution[0];
            const yResolution = resolution[1];

            
            for (var t = 0; t < (renderLists.length / 4); t++) {

                const pixelIndex = t * 4;
                const currentRowNumber = rowNumber;
                const currentRowLegnth = rowLength;

                const pixelColor = `rgb(${renderLists[pixelIndex]}, ${renderLists[pixelIndex + 1]}, ${renderLists[pixelIndex + 2]})`;
                // const pixelColor = `rgb(255, 0, 0)`;
                var pixelLength = renderLists[pixelIndex + 3];
                rowLength += pixelLength


                if (rowLength > xResolution) {
                    
                    const shortendPixelLength = xResolution - currentRowLegnth;
                    const leftPixelLength = pixelLength - shortendPixelLength;
                    pixelLength = shortendPixelLength;
                    
                    renderLists[pixelIndex + 3] = leftPixelLength;

                    t += -1;

                    rowNumber += 1;
                    rowLength = 0;
                }

                
                CanvasContext.fillStyle = pixelColor;
                CanvasContext.fillRect(currentRowLegnth * pixelSize, currentRowNumber * pixelSize, pixelLength * pixelSize, pixelSize);
            }
        }

        var sideWidth = getDisplayResolution()[0] * 0.2;
        if (sideWidth < 300) {
            sideWidth = 300;
        }
        window.scrollTo(0, 0);
        setCanvasSize("pixelCanvas", determineCanvasResolution());
        // setInterval(setCanvasSize("pixelCanvas", determineCanvasResolution()), 100);
        // setInterval(forgetRequest(), 1000);
        addVector("Config");
        setInterval(IncrementSlider, 50);
        

        //sendPutRequest("X");
        //sendPutRequest("Y");
        //sendPutRequest("Z");
        sendPutRequest(-1);

        increaseSlider(-1)

        // If you want to automatically call the function every second
        //setInterval(async () => {await sendPutRequest(-1)}, 50);
        //setInterval(increaseSlider(-1), 100);

    </script>
</body>
</html>